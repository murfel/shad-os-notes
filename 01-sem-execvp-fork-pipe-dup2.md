# Семинар 1

Домашка - проэмулировать баш, чтобы можно было выполнять такие команды:
```
$ echo hi
$ echo hi >a.txt <a.in
$ cat a.txt | wc -l | ... | ... | ...
```

## execvp и fork
```
execvp(cmd, [args])
execvp(echo, [echo hi]) -> exit(0)

    |
    |
    v
   fork
|        |
v        v
ret 42;  ret 0;

if (fork() > 0) {
    // копия
} else {
    // оригинал
}

waitpid(42) -> ret - ждём завершение дочернего процесса, узнаем его код возврата через ret.
```

fork
- Оптимизация copy-on-write для памяти.
- Нужно думать про разделяемые ресурсы.
- У ребёнка будет _копия_ файловых дескрипторов. Если родитель прочитал из файла, позиция в файле у ребенка не изменится.
- При форке многопоточного процесса в копии будет только один тред.
  - Если была захвачена блокировка во втором потоке, то в копии никто никогда не сможет ее отпустить.
- Форк с разделяемыми ресурсами. Можно сделать fork-aware spinlock, обсудим в лекции про блокировки.

## Перенаправление ввода/ввывода
Хотим подменить ввод-ввывод на наши файлы.

```
open('a.txt', flags, mode) -> fd
dup2(x, y)  // close(y), y = clone(x)
close(fd)
```

`open` - открытие файла. Флаги: на чтение, на запись, создать файл если его нет. mode - права на файл, в случае его создания.

Клон дескриптора - чтение по одному не двигает другой.

Номера файловых дескрипторов для ввода-вывода:
```
stdin 0
stdout 1
stderr 2
```

## Pipe
### Склеить вывод одной команды в ввод другой.

`pipe() -> (x, y)` - создаёт трубу, где на входе файловый дескриптор x, на выходе - y: `x -> ()======() -> y`. Все, что пишется в x, будет читать y.

### Запускать много процессов из одного процесса.
Построить дерево процессов из форков.
```
   /\
  /  \
c1   /\
    /  \
   c2  /\
  ... /  \
     cn
```
Создаём пайп для c1-c2, форкаемся в c2 и т.д.
